<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用Sphinx将个人笔记变成文档的形状~</title>
      <link href="articles/2021-01%E4%BD%BF%E7%94%A8Sphinx%E5%B0%86%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E5%8F%98%E6%88%90%E6%96%87%E6%A1%A3%E7%9A%84%E5%BD%A2%E7%8A%B6/"/>
      <url>articles/2021-01%E4%BD%BF%E7%94%A8Sphinx%E5%B0%86%E4%B8%AA%E4%BA%BA%E7%AC%94%E8%AE%B0%E5%8F%98%E6%88%90%E6%96%87%E6%A1%A3%E7%9A%84%E5%BD%A2%E7%8A%B6/</url>
      
        <content type="html"><![CDATA[<p>本文从记录笔记和后期归档出发，对比了多个平台记录笔记的特点和优势，最后详细记录了使用Sphinx编译笔记为html的例子。</p><a id="more"></a><h2 id="需求分析-amp-平台对比"><a href="#需求分析-amp-平台对比" class="headerlink" title="需求分析&amp;平台对比"></a>需求分析&amp;平台对比</h2><p>首先关于为什么选用Sphinx编译笔记和文档，Hexo和gitbook也挺香的。Sphinx是综合对比下的选择。</p><p>首先是Typora，它简直就是写md的神器，写md的同时还能预览，没有大部分md编辑器左边写md右边预览的那种割裂感。但只适合单个文档的编辑，如果加上多标签那就完美了。有时大概有印象要找的内容在某篇笔记中，但没法全局搜索就有些麻烦。</p><p>然后有朋友推荐了gitnote，虽然它可以多标签页编辑多个md了，但问题同样是显著的——慢且默认为md编辑模式，预览还得多切换一次。慢是说它每次启动都得卡半天（已经安装在固态盘中），且经常会有高CPU和磁盘占用，可能会定时扫描文件变动实现版本管理。</p><p>也参考了朋友的意见使用Trello记录笔记，但感觉它更多是针对工作流的，对于个人笔记而言好像又太复杂了。</p><p><img src="http://ww1.sinaimg.cn/large/008eYjoEly1gmpa6o0wa8j30zm0jlgop.jpg" alt="image-20210116085358179"></p><p>至此我的需求大致明确，平常记录笔记使用md；后期方便查阅和搜索；查阅和搜索时秒开；最好有多标签，没有也可以；最后，编译出来的颜值要够。因而将目标转向了将md文件编译为html的一些框架，编辑和整理时通过Typora书写，查阅时可以通过网页的形式全局搜索。</p><p>gitbook和Hexo等框架可以很方便的将md文件编译为html，但gitbook编译出的html需要挂在Nginx上，不然没法跳转；hexo虽然没有上述缺点，但它是针对blog的框架，不太适合笔记。因而最终选定了Sphinx，静态网页且够快够好看。</p><p>使用Nginx挂载gitbook编译的链接可以参考我以前的推文：<a href="https://mp.weixin.qq.com/s/mRwajAm06Z0dUV0oz54_Uw">《开发文档加载不再卡顿，亿点点提升》</a></p><h2 id="使用Sphinx记笔记"><a href="#使用Sphinx记笔记" class="headerlink" title="使用Sphinx记笔记"></a>使用Sphinx记笔记</h2><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>首先安装必要的包，我用的python环境是Anaconda，日常不激活conda环境而是直接用。安装包用匹配即可，用conda管理环境反而麻烦（在不需要做环境隔离的情况下）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install sphinx sphinx_rtd_theme sphinx-autobuild </span><br><span class="line">pip3 install recommonmark sphinx_markdown_tables </span><br></pre></td></tr></table></figure><p>首先安装本体和一个主题，还有一个自动编译的工具。第二行安装了两个插件，添加了对md文件的支持。</p><h3 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h3><p>在一个空目录下运行<code>sphinx-quickstart</code>，输出的信息大致如下，除了最后的语言注意填写<code>zh_CN</code>，其他的几个随便填，后面可以改。</p><p><img src="http://ww1.sinaimg.cn/large/008eYjoEly1gmpa6nse0aj30m80dwwfp.jpg" alt="image-20210114222655913"></p><p>生成文件后有一些奇奇怪怪的文件，需要关注的有两个</p><ul><li>conf.py： Sphinx 的配置，设置插件主题等</li><li>index.rst：文档项目起始文件。</li></ul><p>打开<code>conf.py</code>，修改主题，添加插件，找到相关的内容改成这样。还可以添加其他的插件实现其他的效果和功能，<code>sphinx_rtd_theme</code>主题比较好看，有其他颜值高的主题求推荐一波。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extensions &#x3D; [</span><br><span class="line">&#39;recommonmark&#39;,</span><br><span class="line">&#39;sphinx_markdown_tables&#39;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">html_theme &#x3D; &#39;sphinx_rtd_theme&#39;</span><br></pre></td></tr></table></figure><p>至此，可以在有<code>make.bat</code>或者<code>Makefile</code>的目录下运行<code>make html</code>编译文档，编译出来的文件在<code>build\html</code>目录下。</p><p>可以使用<code>sphinx-autobuild</code>命令自动编译，可以实时刷新写好的文档，但是文档有错误时不会显示报错信息。会在<code>localhost</code>的某个端口挂载编译好的静态html，并实时刷新。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sphinx-autobuild source build&#x2F;html</span><br></pre></td></tr></table></figure><h3 id="编写自己的文档和笔记"><a href="#编写自己的文档和笔记" class="headerlink" title="编写自己的文档和笔记"></a>编写自己的文档和笔记</h3><p>sphinx用的是一套叫reStructuredText的纯文本标记语法，功能比md更丰富，<a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html">语法参考链接</a>。</p><p>不过写文档可以不用太了解rst的语法，打开<code>index.rst</code>，结构大致如下</p><p>toctree的三个空格很重要，了少了都报错，最下面的是参考链接，可以不要。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">这是标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">可以写点什么东西</span><br><span class="line"></span><br><span class="line">.. toctree::</span><br><span class="line">   :maxdepth: 2</span><br><span class="line">   :caption: 目录标题:</span><br><span class="line">   </span><br><span class="line">   about</span><br><span class="line">   test&#x2F;testfile</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">这也是标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line"></span><br><span class="line">* :ref:&#96;genindex&#96;</span><br><span class="line">* :ref:&#96;modindex&#96;</span><br><span class="line">* :ref:&#96;search&#96;</span><br></pre></td></tr></table></figure><p>在<code>index.rst</code>的toctree下面加入自己写的内容后要建立对应的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir test</span><br><span class="line">touch about.md</span><br><span class="line">touch test\testfile.md</span><br></pre></td></tr></table></figure><p>由于之前安装的<code>recommonmark</code>插件，可以愉快的使用md写文档了。</p><p>可以把下面的内容粘贴到新建的md中，方便编译测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 标题1</span><br><span class="line"></span><br><span class="line">## 标题2</span><br><span class="line"></span><br><span class="line">### 标题3</span><br><span class="line"></span><br><span class="line">#### 标题4</span><br><span class="line"></span><br><span class="line">##### 标题5</span><br><span class="line"></span><br><span class="line">##### 标题6</span><br><span class="line"></span><br><span class="line">正文正文</span><br></pre></td></tr></table></figure><p>最终完成的效果，奇怪的笔记文档增加了。</p><p><img src="http://ww1.sinaimg.cn/large/008eYjoEly1gmpa6nspyrj31270nfjt0.jpg" alt="image-20210114225944865"></p><p>使用Sphinx编译自己的笔记文档还挺简单的，但是没搞明白之前还是挺蛋疼的，参考了一些链接但感觉还是写的不是太清楚，故我自己总结一下。</p><h2 id="问题和改进"><a href="#问题和改进" class="headerlink" title="问题和改进"></a>问题和改进</h2><h3 id="中文路径"><a href="#中文路径" class="headerlink" title="中文路径"></a>中文路径</h3><p>目前出现了文档中存在中文路径时无法正常读取图片的bug，猜测是转义出了问题，不过没有修复完成。</p><p><img src="http://ww1.sinaimg.cn/large/008eYjoEly1gmpa6ns8itj30m80dwjtr.jpg" alt="image-20210114204629844"></p><h3 id="风格主题"><a href="#风格主题" class="headerlink" title="风格主题"></a>风格主题</h3><p>现在使用的主题还有一点不太满意，代码高亮风格和其他的一些细节想改改，后续可能会研究研究怎么修改。</p><h3 id="一文多发"><a href="#一文多发" class="headerlink" title="一文多发"></a>一文多发</h3><p>众所周知md是最好的纯文本标记语言（狗头），csdn、知乎、公众号或者其他平台都支持md格式的文档。唯一的问题就是在本地环境下图片是相对路径，辗转到各个平台还得重新上传图片。一个解决办法是使用图床，将文档内的图片替换为外链后就可以多个平台复制粘贴发送一气呵成。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/264647009">春夏秋冬的例子</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-sphinx-documentation/">一个大佬比较详细的配置过程</a></li><li><a href="https://www.sphinx-doc.org/en/master/usage/restructuredtext/basics.html">官方res语法参考</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIO——让无人机更自主更智能</title>
      <link href="articles/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/"/>
      <url>articles/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/</url>
      
        <content type="html"><![CDATA[<p>让无人机送外卖也许在现在看来还有很长一段距离得走，但是这些应用场景任务总是让人心驰神往。智能任务固然让人心动，但如何让这些任务落地也是困扰学界的一个难题。</p><p>本人在北航可靠飞行控制研究组完成本科毕业设计。本文节选于“ <strong>杨思捷. 基于视觉的多旋翼无人机集群室外局部自主定位[D] 北京航空航天大学本科学位论文，北京。</strong>”</p><a id="more"></a><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/1-%E6%97%A0%E4%BA%BA%E6%9C%BA%E9%80%81%E5%A4%96%E5%8D%96.gif"></p><h2 id="研究背景——集群-越障"><a href="#研究背景——集群-越障" class="headerlink" title="研究背景——集群+越障"></a>研究背景——集群+越障</h2><p>从送外卖的例子推广开，为了让无人机完成一些自主和智能任务，归根结底是要解决两个问题：导航和避障。空中并非空无一物，飞行的鸟类，同样执行任务的无人机，高大的建筑和树木······无人机都有可能和这些物体发生碰撞，因而需要一定的避障方法。</p><p>为了更形象的解释无人机执行任务，从哲学三问出发，是谁，在哪，去哪。作为一个无人机，是谁这个问题的答案很明确；导航回答了在哪的问题，通过GPS定位获得全球的经纬度位置；去哪是由任务所决定的，不同的任务指定了不同的目的地。但就如人生难免有挫折一样，无人机在执行任务的路上也难免遇到绊子。首先是GPS定位的问题，不是所有的地方都有GPS信号，在山谷中，城市的建筑之间，森林或者电力输送线周边等环境中会因遮挡和电磁干扰等因素GPS信号受到干扰，无人机将产生不可预料的行为更有可能坠毁造成人员伤亡和财产损失。</p><p>既然GPS好像不是那么好使，那么有没有一种方法可以在GPS信号不好甚至没有GPS环境下提供定位呢？答案是肯定的，可以使用视觉惯性里程计（Visual-Inertial Odometry,  VIO）或者提供局部定位。下面将结合本人的毕设介绍VIO。无人机要完成的任务来源空军装备部主办第二届“无人争锋”挑战赛，比赛任务要求无人机集群在无GPS环境下以密集编队形式按照规定路线飞行，并依次穿越路线上门框。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/image-20200623113846339.png"></p><p>毕设中设计的解决方案是，通过VIO进行局部定位在GPS拒止环境下提供定位；使用视觉伺服的方法控制无人机接近并穿越门框；施加人工势场的避障分量避免无人机碰撞；通过融合多个相对位置的来源提高集群之间定位的精度。</p><h2 id="VIO是什么"><a href="#VIO是什么" class="headerlink" title="VIO是什么"></a>VIO是什么</h2><p>VIO是一种将图像和IMU数据作为输入，相机移动轨迹/相机当前位置作为输出的模块。它与SLAM（Simultaneous Localization And Mapping）有着紧密的联系。经典视觉SLAM框架如下图所示：</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/image-20200602214348963.png"></p><p><strong>传感器</strong>一般为相机图像，IMU和码盘等，将读取到的数据送至前端进行处理；<strong>前端</strong>可以通过读取到的数据计算相邻数据帧之间的运动；前端得到的运动轨迹并不全局一致，<strong>后端</strong>通过非线性优化获得全局一致的结果，系统中不一定有回环检测，若有将回环的结果也加入后端优化中结果会更准确；<strong>回环检测</strong>判断机器人是否处于之前走过的位置，若是则将数据传至后端进行优化；<strong>建图</strong>是根据之前的数据建立符合任务要求的地图。一般可以认为VIO是SLAM的一个子集，VIO包括了传感器读取前端后端的部分，不一定有回环检测；而定位+建图才是SLAM，SLAM必定包括回环，因为SLAM建立的地图是全局一致的。关于SLAM的综述推荐文献[1]。</p><p>下面还有几点需要说明：</p><ol><li><p>若前端处理的只有图像数据则为视觉里程计（Visual Odometry,  VO）例如<a href="https://gaas.gitbook.io/guide/software-realization-build-your-own-autonomous-drone/wu-ren-ji-zi-dong-jia-shi-xi-lie-part-3-zai-wu-gps-huan-jing-xia-tong-guo-slam-shi-xian-wei-zhi-gu-j">GASSE03</a>使用的<code>ygz_slam_ros</code>前端是只利用了图像的VO。</p></li><li><p>VIO是融合了图像和IMU数据，融合的方式有松耦合和紧耦合两种。松耦合是将图像输入VO得到位姿$\mathbf{T}^-$后融合IMU数据得到更可靠的位姿$\mathbf{T}^+$；紧耦合是输入图像，提取特征，与IMU数据一起估计位姿。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/image-20200602221602313.png"></p></li><li><p>关于后端非线性优化的部分，一般有滤波和优化两种方法，可以认为滤波方法是只进行了一次迭代的优化方法。而关于滤波和优化的优劣还以实物效果为准，优化方法的精度较高但计算量大实时性差，滤波方法相反效率高但精度有所下降。</p></li></ol><p>目前较为成熟的VIO框架和模型有MSCKF[2], ROVIO[3], OKVIS[4]和VINS-Mono[5]。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/image-20200604144039204.png"></p><h2 id="仿真实验"><a href="#仿真实验" class="headerlink" title="仿真实验"></a>仿真实验</h2><p>仿真实验基于AirSim进行，AirSim是一款基于虚幻引擎的无人机无人车模拟器，开源且支持跨平台，并可以和PX4飞控等硬件联合调试进行硬件在环仿真和软件在环仿真，实现物理和视觉上的逼真模拟。下图是任务模块和系统框架的设计</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/image-20200623115416041.png"></p><h3 id="VIO定位"><a href="#VIO定位" class="headerlink" title="VIO定位"></a>VIO定位</h3><p>VIO对数据频率要求比较高，要求图像数据频率在20Hz以上，IMU频率在200Hz以上。仿真环境由于计算机平台的性能限制，无法达到那么高的数据频率，因而精度对比实际的效果会差一些。下面展示了一个无人机飞行20mx10m长方形轨迹的例子。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/2-VIO%E8%BD%A8%E8%BF%B9%E4%BE%8B%E5%AD%90.gif"></p><h3 id="视觉伺服"><a href="#视觉伺服" class="headerlink" title="视觉伺服"></a>视觉伺服</h3><p>比赛中需要穿越的门框为红色，提取门框特征后传入视觉伺服算法控制无人机接近并穿越门框</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/3-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E7%9A%84%E4%BE%8B%E5%AD%90.gif"></p><h3 id="任务整体演示"><a href="#任务整体演示" class="headerlink" title="任务整体演示"></a>任务整体演示</h3><p>4机集群</p><video src='https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/4-4%E6%9C%BA%E9%9B%86%E7%BE%A4.mp4' type='video/mp4' controls='controls'  width='100%' height='100%'></video><p>25机集群</p><video src='https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/5-25%E6%9C%BA%E9%9B%86%E7%BE%A4.mp4' type='video/mp4' controls='controls'  width='100%' height='100%'></video><p>第一人称视角</p><video src='https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06%E5%AE%9E%E9%AA%8C%E5%AE%A4%E5%85%AC%E4%BC%97%E5%8F%B7/6-%E7%AC%AC%E4%B8%80%E4%BA%BA%E7%A7%B0%E8%A7%86%E8%A7%92.mp4' type='video/mp4' controls='controls'  width='100%' height='100%'></video><h2 id="总结与展望"><a href="#总结与展望" class="headerlink" title="总结与展望"></a>总结与展望</h2><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>基于AirSim搭建任务场景，提供了和现实场景类似的任务环境，并在仿真中实现无人机集群密集编队，完成了越障任务</li><li>VIO提供相对位置进行自主飞行，视觉伺服控制无人机越障，人工势场避免无人机集群避障</li></ul><h3 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h3><ul><li>仿真平台可以推广到其他任务，通过仿真提供先验数据并为实际的实验排除一切问题</li><li>可以简单的从仿真环境迁移到实物环境，在仿真环境的基础上针对实物环境的干扰进行优化和处理，可以实现和仿真环境相同的效果</li></ul><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>[1]  刘浩敏, 章国锋, 鲍虎军. 基于单目视觉的同时定位与地图构建方法综述[J]. 计算机辅助设计与图形学学报, 2016, 28(6): 855-868.</p><p>[2]  Mourikis A, Roumeliotis S. A multi-state constraint Kalman filter for vision-aided inertial navigation[C]. Proceedings of IEEE International Conference on Robotics and Automation. Los Alamitos: IEEE Computer Society Press, 2007: 3565-3572</p><p>[3]  Sun K, Mohta K, Pfrommer B. Robust stereo visual inertial odometry for fast autonomous flight[J]. IEEE Robotics and Automation Letters, 2018, 3(2): 965-972.</p><p>[4]  Leutenegger S, Lynen S, Bosse M. Keyframe-based visual–inertial odometry using nonlinear optimization[J]. The International Journal of Robotics Research, 2015, 34(3): 314-334.</p><p>[5] Qin T, Li P, Shen S. Vins-mono: A robust and versatile monocular visual-inertial state estimator[J]. IEEE Transactions on Robotics, 2018, 34(4): 1004-1020.</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AirSim </tag>
            
            <tag> VIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何在AirSim中优雅的运行SLAM/VIO</title>
      <link href="articles/2020-06VIO/"/>
      <url>articles/2020-06VIO/</url>
      
        <content type="html"><![CDATA[<p>本文首先解释了什么是VIO，介绍了VIO和SLAM的联系并对现有的VIO框架进行了调研，最后以Rovio和Vins为例，展示了如何在AirSim里跑VIO。</p><a id="more"></a><h2 id="何为SLAM-VIO"><a href="#何为SLAM-VIO" class="headerlink" title="何为SLAM/VIO"></a>何为SLAM/VIO</h2><p>视觉惯性里程计（Visual-Inertial Odometry,  VIO）是一种将图像和IMU数据作为输入，相机移动轨迹/相机当前位置作为输出的模块。它与SLAM（Simultaneous Localization And Mapping）有着紧密的联系。经典视觉SLAM框架如下图所示，图参考了高翔博士的《视觉SLAM十四讲》。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06VIO/image-20200602214348963.png"></p><p>假定我们的对象为一个搭载有各种传感器的机器人。<strong>传感器</strong>一般为相机图像，IMU和码盘等，将读取到的数据送至前端进行处理；<strong>前端</strong>可以通过读取到的数据计算相邻数据帧之间的运动；前端得到的运动轨迹并不全局一致，<strong>后端</strong>通过非线性优化获得全局一致的结果，系统中不一定有回环检测，若有将回环的结果也加入后端优化中结果会更准确；<strong>回环检测</strong>判断机器人是否处于之前走过的位置，若是则将数据传至后端进行优化；<strong>建图</strong>是根据之前的数据建立符合任务要求的地图。一般可以认为VIO是SLAM的一个子集，VIO包括了传感器读取前端后端的部分，不一定有回环检测；而定位+建图才是SLAM，SLAM必定包括回环，因为SLAM建立的地图是全局一致的。</p><p>下面还有几点需要说明：</p><ol><li><p>若前端处理的只有图像数据则为视觉里程计（Visual Odometry,  VO）例如<a href="https://gaas.gitbook.io/guide/software-realization-build-your-own-autonomous-drone/wu-ren-ji-zi-dong-jia-shi-xi-lie-part-3-zai-wu-gps-huan-jing-xia-tong-guo-slam-shi-xian-wei-zhi-gu-j">GASSE03</a>使用的<code>ygz_slam_ros</code>前端只利用了图像是一个VO（貌似可以加IMU不过好像没有完成？）。</p></li><li><p>VIO是融合了图像和IMU数据，融合的方式有松耦合和紧耦合两种。松耦合是将图像输入VO得到位姿$\mathbf{T}^-$后融合IMU数据得到更可靠的位姿$\mathbf{T}^+$；紧耦合是输入图像，提取特征，与IMU数据一起估计位姿。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06VIO/image-20200602221602313.png"></p></li><li><p>关于后端非线性优化的部分，一般有滤波和优化两种方法，可以认为滤波方法是只进行了一次迭代的优化方法。而关于滤波和优化的优劣还以实物效果为准，优化方法的精度较高但计算量大实时性差，滤波方法相反效率高但精度有所下降。</p></li></ol><h2 id="VIO现状"><a href="#VIO现状" class="headerlink" title="VIO现状"></a>VIO现状</h2><p>视觉SLAM（Simultaneous Localization And Mapping）的代表性工作包括PATM、LSD-SLAM、SVO、ORB-SLAM。关于SLAM的综述推荐文献[1]。目前较为成熟的VIO框架和模型有MSCKF[2], ROVIO[3], OKVIS[4]和VINS-Mono[5]。</p><p>MSCKF(Multi-State Constraint Kalman Filter)是基于滤波器SLAM的经典实现。MSCKF相比于传统的滤波器SLAM的创新在于应用了滑动窗口。在传统的EKF-SLAM框架中，特征点的信息会加入到特征向量和协方差矩阵中，相当于特征点的信息给定了初始深度和初始协方差的值。如果这个值错误，后续的计算中会发散。MSCKF维护一个FIFO的滑动窗口当特征点在滑动窗口的几个位姿都被观察到的时建立几个位姿间的约束进而更新滤波器。</p><p>ROVIO是于2015年提出的以EKF为主的VIO，它将将视觉信息和IMU信息通过迭代拓展卡尔曼滤波(IEKF, Iterated Extended Kalman Filter)进行紧耦合。ROVIO将路标点及其周围的图像作为路标点的描述子，得到光度误差后变换至IEKF的更新项。整个系统使用固连关信息从而减小非线性引起的误差，而空间路标信息被分解为集束向量和深度倒数从而使得初始化无延迟。ROVIO精度和鲁棒性相对不错，在低速移动条件下可以以20Hz输出位姿信息（测试平台的CPU为i7-2760QM）；而角速度约为3.5rad/s的高速移动条件下可以较好拟合真实的移动数据；实机飞行实验中，无外加校准信息时在起飞阶段即可完成初始化。</p><p>OKVIS是由 Stefan Leutenegge 等人提出的基于双目+惯导的视觉里程计，其算法是基于关键帧优化的紧耦合VIO。OKVIS是通过 IMU 测量值对当前状态做预测，根据预测进行特征提取和特征匹配，3D 点特征和二维图像特征构成优化中重投影，同时预测的 IMU 的状态量和优化的参数之间构成 IMU 测量误差，这两项误差放在一起做优化。</p><p>VINS-Mono是以优化关键帧为主的VI-SLAM。首先在第一个关键帧中寻找最强的150个特征点，通过非极大值抑制半径减少误匹配。下一关键帧输入后通过光流法进行特征点匹配，经过相机畸变等校正后将位置信息发出。若在运行过程中特征点丢失会用最强最新的特征点补足。在高度为60m的实机飞行测试中，总长5.62km的路程累计漂移约为0.29%（16m）。VINS-Mono使得SLAM的应用更偏向单目视觉+IMU。单目视觉能够适应室内、室外及不同光照的环境，具有较好的适应性。</p><p>关于VIO的对比表</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06VIO/image-20200604144039204.png"></p><h2 id="优雅的运行VIO"><a href="#优雅的运行VIO" class="headerlink" title="优雅的运行VIO"></a>优雅的运行VIO</h2><p>如何在AirSim里面优雅（并不）的运行VIO呢，要解决的问题主要有两个：坐标系对齐和数据频率。以ROVIO和Vins-Fusion为例。有关二者的编译和运行参见：</p><p>ROVIO：<a href="https://github.com/ethz-asl/rovio">https://github.com/ethz-asl/rovio</a></p><p>Vins-Fusion：<a href="https://github.com/HKUST-Aerial-Robotics/VINS-Fusion">https://github.com/HKUST-Aerial-Robotics/VINS-Fusion</a></p><p><a href="https://projects.asl.ethz.ch/datasets/doku.php?id=kmavvisualinertialdatasets">Euroc数据集</a>是一个标准的数据集，可以用来测试VIO/SLAM的精度。我们的思路是先把Euroc数据集跑通，然后从Euroc数据集推广到AirSim的数据。由于服务器在国外，官网下载比较慢，20kb/s龟速下载，之前找了百度云的分享，关注公众号回复“数据集”即可获得下载链接。</p><h3 id="运行数据集"><a href="#运行数据集" class="headerlink" title="运行数据集"></a>运行数据集</h3><p>Rovio比较简单，自带launch文件，运行launch文件后播放数据集</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">roslaunch rovio rovio_node.launch</span><br><span class="line">rosbag play &lt;下载的数据集&gt;</span><br></pre></td></tr></table></figure><p>打开launch文件康康，可以看到滤波器配置和相机配置文件的路径，如果坐标系的转换关系、相机参数、滤波器参数改变修改对应的配置文件。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06VIO/image-20200604175556665.png"></p><p>Vins也差不多，不过没有现成的launch文件自己写一个，从运行的例子可以看出，配置文件主要在<code>config</code>文件夹下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rosrun vins vins_node ~&#x2F;catkin_ws&#x2F;src&#x2F;VINS-Fusion&#x2F;config&#x2F;euroc&#x2F;euroc_mono_imu_config.yaml </span><br></pre></td></tr></table></figure><p>自己写launch文件，后面修改相机参数就比较方便了</p><p>![](<a href="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06VIO/Screenshot">https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06VIO/Screenshot</a> from 2020-06-04 18-08-21.png)</p><h3 id="调整坐标系"><a href="#调整坐标系" class="headerlink" title="调整坐标系"></a>调整坐标系</h3><p>首先定义坐标系，相机系和机体系，在Euroc数据集中的图示大概如下。从相机系转到机体系绕相机系的z轴转-90°。一般而言红色对应x轴，绿色对应y轴，蓝色对应z轴。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06VIO/platform-1591266708028.jpg"></p><p>在Rovio中旋转用四元数表示，在VINS中用齐次矩阵表示，可以通过配置文件的参数看出，旋转对应着绕z轴转-90°</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Rovio</span><br><span class="line">Camera0</span><br><span class="line">&#123;</span><br><span class="line">qCM_x  0.00666398307551;</span><br><span class="line">qCM_y  -0.0079168224269;</span><br><span class="line">qCM_z  -0.701985972528;</span><br><span class="line">qCM_w   0.712115587266;</span><br><span class="line">MrMC_x -0.0111674199187;</span><br><span class="line">MrMC_y -0.0574640920022;</span><br><span class="line">MrMC_z 0.0207586947896;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VINS</span><br><span class="line">body_T_cam0: !!opencv-matrix</span><br><span class="line">   rows: 4</span><br><span class="line">   cols: 4</span><br><span class="line">   dt: d</span><br><span class="line">   data: [0.0148655429818, -0.999880929698, 0.00414029679422, -0.0216401454975,</span><br><span class="line">           0.999557249008, 0.0149672133247, 0.025715529948,  -0.064676986768,</span><br><span class="line">           -0.0257744366974, 0.00375618835797, 0.999660727178, 0.00981073058949,</span><br><span class="line">           0, 0, 0, 1]</span><br></pre></td></tr></table></figure><p>经过测试，使用AirSim的SampleFlight时机体系是FRD，则对应的转换矩阵为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Rovio</span><br><span class="line">Camera0</span><br><span class="line">&#123;</span><br><span class="line">   qCM_x  -0.500878515967;</span><br><span class="line">   qCM_y  -0.50215775337;</span><br><span class="line">   qCM_z  -0.499875139004;</span><br><span class="line">   qCM_w  0.497074590357;</span><br><span class="line">   MrMC_x -0.00479785;</span><br><span class="line">   MrMC_y 0.005052;</span><br><span class="line">   MrMC_z -0.01413185;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">VINS</span><br><span class="line">body_T_cam0: !!opencv-matrix</span><br><span class="line">  rows: 4</span><br><span class="line">  cols: 4</span><br><span class="line">  dt: d</span><br><span class="line">  data: [0, 0, 1, 0.35,</span><br><span class="line">        1, 0, 0, 0.05,</span><br><span class="line">        0, 1, 0, 0.1, </span><br><span class="line">        0., 0., 0., 1 ]</span><br></pre></td></tr></table></figure><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06VIO/image-20200604212301728.png">在</p><p>MAVROS中是FLU</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Rovio</span><br><span class="line">Camera0</span><br><span class="line">&#123;</span><br><span class="line">   qCM_x  0.500878515967;</span><br><span class="line">   qCM_y  -0.50215775337;</span><br><span class="line">   qCM_z  0.499875139004;</span><br><span class="line">   qCM_w  0.497074590357;</span><br><span class="line">   MrMC_x -0.00479785;</span><br><span class="line">   MrMC_y 0.005052;</span><br><span class="line">   MrMC_z -0.01413185;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VINS</span><br><span class="line">body_T_cam0: !!opencv-matrix</span><br><span class="line">  rows: 4</span><br><span class="line">  cols: 4</span><br><span class="line">  dt: d</span><br><span class="line">  data: [0, 0, 1, 0.35,</span><br><span class="line">        -1, 0, 0, 0.05,</span><br><span class="line">        0, -1, 0, 0.1, </span><br><span class="line">        0., 0., 0., 1 ]</span><br></pre></td></tr></table></figure><h3 id="数据频率"><a href="#数据频率" class="headerlink" title="数据频率"></a>数据频率</h3><p>然后就是数据频率的问题，上一篇推文写了仿真的数据频率和实际的数据频率相比是差很多的，主要是IMU的频率差了5-10倍，因而效果会比较糟糕。大多数时候跑着跑着就发散了23333，不过AirSim有调整时钟频率选项，现实世界经过1s，AirSim的仿真环境中经过xs。改小之后情况有所改善，恩，有所改善。没尝试过放慢后用SITL跑VIO，SITL时的IMU数据是从<code>mavros</code>中产生，大概也会有相同的效果？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;ClockSpeed&quot;: x,</span><br></pre></td></tr></table></figure><h3 id="优雅（并不）的上手"><a href="#优雅（并不）的上手" class="headerlink" title="优雅（并不）的上手"></a>优雅（并不）的上手</h3><p>下面是在分布式情况下跑的例子，用的SampleFlight，会尝试跑SITL但很容易发散。</p><p>首先修改配置文件，利用AirSim的ros包获取IMU和图像数据，只有在<code>Vehicles</code>里面的实例中添加传感器信息AirSim的ros包才会获取相关数据。配置文件两台机子上要一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;SeeDocsAt&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;AirSim&#x2F;blob&#x2F;master&#x2F;docs&#x2F;settings.md&quot;,</span><br><span class="line">  &quot;SettingsVersion&quot;: 1.2,</span><br><span class="line">  &quot;SimMode&quot;: &quot;Multirotor&quot;,</span><br><span class="line">  &quot;ViewMode&quot;: &quot;NoDisplay&quot;,</span><br><span class="line">  &quot;ClockSpeed&quot;: 0.25,</span><br><span class="line">  &quot;Vehicles&quot;: &#123;</span><br><span class="line">    &quot;mav_00&quot;: &#123;</span><br><span class="line">      &quot;VehicleType&quot;: &quot;SimpleFlight&quot;,</span><br><span class="line">      &quot;Sensors&quot;: &#123;&quot;imu&quot;: &#123;&quot;SensorType&quot;: 2, &quot;Enabled&quot;: true &#125; &#125;,</span><br><span class="line">      &quot;Cameras&quot;: &#123;&quot;ccam&quot;: &#123;&quot;CaptureSettings&quot;: [&#123;&quot;ImageType&quot;: 0, &quot;Width&quot;: 640, &quot;Height&quot;: 480, &quot;FOV_Degrees&quot;: 90, &quot;TargetGamma&quot;: 1.5 &#125; ], &quot;X&quot;: 0.35, &quot;Y&quot;: -0.05, &quot;Z&quot;: -0.1, &quot;Pitch&quot;: 0, &quot;Roll&quot;: 0, &quot;Yaw&quot;: 0 &#125; &#125;,</span><br><span class="line">      &quot;X&quot;: 0, &quot;Y&quot;: 0, &quot;Z&quot;: 0, &quot;Pitch&quot;: 0, &quot;Roll&quot;: 0, &quot;Yaw&quot;: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行AirSim的ros包，cd到AirSim源码目录，编译，运行。编译的时候好像要求gcc8，当时遇到过坑不过好像问题不大，搜一下就解决了，所以忘记了（吐舌）。<code>airsim_node.launch</code>里面改一下ip。数据量还是蛮大的，大概30MB/s建议配一个千兆路由器或者网线直连。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;AirSim_Linux&#x2F;ros</span><br><span class="line">catkin_make</span><br><span class="line">source devel&#x2F;setup.bash</span><br><span class="line">roslaunch airsim_ros_pkgs airsim_node.launch</span><br></pre></td></tr></table></figure><p>IMU数据和图像数据就推出来了，修改VIO的launch文件后运行，需要remap一下相应的话题</p><p>对Rovio而言需要多写一个图像转换的节点，Rovio要求输入的图像是灰度图，滤波器和相机的配置文件复制了一份原版，然后按照上一步调整坐标系的步骤修改了参数。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06VIO/image-20200604193345730.png"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source devel&#x2F;setup.bash</span><br><span class="line">roslaunch rovio &lt;自己写的launch&gt;</span><br></pre></td></tr></table></figure><p>对Vins而言也差不多，把3.1写的launch跑起来就ok了。</p><p>下面是演示视频</p><h2 id="文献列表"><a href="#文献列表" class="headerlink" title="文献列表"></a>文献列表</h2><p>[1]  刘浩敏, 章国锋, 鲍虎军. 基于单目视觉的同时定位与地图构建方法综述[J]. 计算机辅助设计与图形学学报, 2016, 28(6): 855-868.</p><p>[2]  Mourikis A, Roumeliotis S. A multi-state constraint Kalman filter for vision-aided inertial navigation[C]. Proceedings of IEEE International Conference on Robotics and Automation. Los Alamitos: IEEE Computer Society Press, 2007: 3565-3572</p><p>[3]  Sun K, Mohta K, Pfrommer B. Robust stereo visual inertial odometry for fast autonomous flight[J]. IEEE Robotics and Automation Letters, 2018, 3(2): 965-972.</p><p>[4]  Leutenegger S, Lynen S, Bosse M. Keyframe-based visual–inertial odometry using nonlinear optimization[J]. The International Journal of Robotics Research, 2015, 34(3): 314-334.</p><p>[5] Qin T, Li P, Shen S. Vins-mono: A robust and versatile monocular visual-inertial state estimator[J]. IEEE Transactions on Robotics, 2018, 34(4): 1004-1020.</p><p>P.S. 终于写够了原创的篇数可以开启赞赏啦！这篇写了大概3500+吧，如果喜欢我的分享请给我一点支持和鼓励哟。顺便，一开始准备沿用孤独的梦想家的名号的，被占用只好改了hhhh，可怜弱小无助还特么能吃。</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SITL </tag>
            
            <tag> AirSim </tag>
            
            <tag> VIO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Airsim仿真</title>
      <link href="articles/2020-06Airsim%E4%BB%BF%E7%9C%9F/"/>
      <url>articles/2020-06Airsim%E4%BB%BF%E7%9C%9F/</url>
      
        <content type="html"><![CDATA[<p>AirSim是微软在2017年发布的无人机无人车仿真框架，基于虚幻引擎开发。最初的开发目的用于生成机器学习的数据，不过随着这几年功能不断完善，作为机器视觉实验平台和任务仿真的工具也是一个不错的选择。特别是和Pixhawk通过MAVlink链接后可以进行SITL和HITL，可以简单的从仿真环境移植到真实的无人机。</p><p>本文将分享一些AirSim的使用体验，然后简单介绍AirSim仿真环境的搭建，最后介绍AirSim仿真和PX4的SITL的连接。</p><a id="more"></a><h2 id="AirSim体验"><a href="#AirSim体验" class="headerlink" title="AirSim体验"></a>AirSim体验</h2><p>关于AirSim的使用，有三种方式。推荐在Win平台上跑AirSim，局域网里另外一台电脑跑SITL。</p><ol><li><p>下载github编译好的release，不过场景比较有限</p></li><li><p>在win中编译环境，编译出的binary可以直接的复制到其他的win pc中运行，支持Airsim的SimpleFlitht和PX4.的SITL+HITL。大概不能交叉编译，尝试了没成功，也可能是方法不对。</p></li><li><p>在Linux中编译环境，不过不太推荐这么干，UE引擎得编译安装而且编译出来的binary不支持PX4.的相关仿真。不过在之前斯东大佬沟通开了新分支修复了相关的bug，没整合到官方master中。(时间关系，没尝试过用该分支编译环境)</p></li></ol><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06Airsim%E4%BB%BF%E7%9C%9F/image-20200515230754300.png"></p><p>2020年4月AirSim进行了一波大更新，2月的时候用的master分支还是VS2017+UE4.18，前几天更新的时候就迁移到了VS2019+UE4.24。主要的改动如下</p><ol><li><p>VS版本更新，开发环境变化，不过同时安装VS2017和VS2019似乎会导致程序打包的时候出错。</p></li><li><p>UE版本变动，新版本的UE使用了Vulkan驱动，让仿真场景更加丝爽润滑，但也更吃硬件。下面的表格对比了不同环境的图像和IMU频率（v1.3.1的Realse），测试环境（i5-7300+1050TI笔记本）对比实际D435i相机和Euroc数据集的频率仿真的频率还是偏低（也可能是电脑太辣鸡）。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06Airsim%E4%BB%BF%E7%9C%9F/image-20200602155121660.png"></p><p>而对于编译的环境，Airsim版本更新的提升还是有一些的，但感觉没预想中那么大。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06Airsim%E4%BB%BF%E7%9C%9F/image-20200602155400378.png"></p></li><li><p>PX4的固件从v1.8.2更新到v1.10.1，主要影响的是仿真接口，仿真器的链接从UDP转为了TCP，其他的UDP端口略有变化。<img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06Airsim%E4%BB%BF%E7%9C%9F/image-20200602154320711.png"></p><p>更新之后不再支持v1.8.2固件的SITL，这个影响对使用WSL的开发者影响比较大，v1.8之后的SITL因为WSL的bug会因为没有权限创建一个链接，导致仿真没法进行，尝试在脚本里用root权限运行不过不太好使的亚子。可以考虑WSL2/虚拟机/分布式开发。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06Airsim%E4%BB%BF%E7%9C%9F/image-20200515232924152.png"></p></li></ol><h2 id="AirSim环境搭建"><a href="#AirSim环境搭建" class="headerlink" title="AirSim环境搭建"></a>AirSim环境搭建</h2><p>关于AirSim的环境搭建网上已经有不少详细的教程，我就不具体写了。最主要的困难大概就是需要一把稳固的梯子。AirSim插件编译好后可以下载各种UE的素材建立自己的任务环境。</p><p>官方文档：<a href="https://microsoft.github.io/AirSim/build_windows/">https://microsoft.github.io/AirSim/build_windows/</a></p><p>知乎@aaron20127的教程：<a href="https://zhuanlan.zhihu.com/p/43245459">https://zhuanlan.zhihu.com/p/43245459</a></p><h2 id="AirSim-SITL"><a href="#AirSim-SITL" class="headerlink" title="AirSim+SITL"></a>AirSim+SITL</h2><p>AirSim的贴图和纹理对比Gazebo更接近真实场景，跑图像识别和SLAM之类的也比较有优势。AirSim有自带的SampleFlight模式，可以比较方便的验证视觉控制的算法。不过要与实际情况更接近的话还是带上PX4的SITL会好一些。下面列举几个AirSim+SITL的配置，下面的例子是在v1.8.2环境下，v1.10.1修改对应的端口即可。</p><ol><li>WSL运行SITL+主机运行AirSim</li></ol><p>个人更推荐这种方式，Win平台下可以方便的使用UE搭建任务场景，编译出二进制程序后不管是本机运行还是拷贝到其他的电脑上运行都很方便。而编译飞控相关的可以使用WSL，WSL和主机共享IP，通过<code>127.0.0.1</code>可以相互访问。（WSL2就是IP独立，相当于一个Hyper-V虚拟机）</p><p>首先修改AirSim的配置文件，<code>&quot;UseSerial&quot;: false,</code>表明使用SITL而不是HITL，设定相关的端口同上图，若设置集群对应修改飞机和端口号</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;SeeDocsAt&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;AirSim&#x2F;blob&#x2F;master&#x2F;docs&#x2F;settings.md&quot;,</span><br><span class="line">    &quot;SettingsVersion&quot;: 1.2,</span><br><span class="line">    &quot;SimMode&quot;: &quot;Multirotor&quot;,</span><br><span class="line">    &quot;Vehicles&quot;:&#123;</span><br><span class="line">        &quot;mav_00&quot;: &#123;</span><br><span class="line">            &quot;VehicleType&quot;: &quot;PX4Multirotor&quot;,</span><br><span class="line">            &quot;X&quot;: 0, &quot;Y&quot;: 0, &quot;Z&quot;: -1,</span><br><span class="line">            &quot;UseSerial&quot;: false,</span><br><span class="line">            &quot;SitlIp&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">            &quot;SitlPort&quot;: 14556,</span><br><span class="line">            &quot;UdpIp&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">            &quot;UdpPort&quot;: 14560,</span><br><span class="line">            &quot;QgcHostIp&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">            &quot;QgcPort&quot;: 14550</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在WSL里面运行SITL，使用对应版本的编译指令，例如1.8.2的<code>make posix none_iris</code></p><p>先打开QGC地面站，最后打开编译好的环境。AirSim会给QGC发一个HB然后QGC发送一些初始化信息给SITL完成初始化，当初在这里卡了半天。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06Airsim%E4%BB%BF%E7%9C%9F/image-20200602163313679.png"></p><p>这块有一点疑问就是，AirSim的机头朝向正北的时候SITL的数据会有偏差，比如上图所示的yaw为9°。</p><ol start="2"><li>Linux运行SITL+AirSim</li></ol><p>个人感觉挺蛋疼的，在Linux上开发UE。各种FBX格式的模型在Win上建模和制作更顺手来着，而且Linux的虚幻得从源码编译安装，挺费事的。。。反正直观体验不是太好，Ubuntu18.04环境，下载UE源码一个晚上，编译一个晚上，最后在Ubuntu上搭建环境啥的流畅度还不如在Win上。个人极力不推荐。</p><ol start="3"><li>分布式架构</li></ol><p>终于到重头戏了，分布式是我觉得最舒服的开发和仿真方式。笔记本是常用机，双系统，Win开发好了UE的任务环境打包出二进制文件，拷贝到台式机运行。然后笔记本切到Ubuntu，跑ROS和SITL相关的玩意。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-06Airsim%E4%BB%BF%E7%9C%9F/image-20200602161432813.png"></p><p>分布式的注意事项和之前的差不多，记得先开GCS，不过配置文件需要修改IP地址，其中<code>LocalHostIp</code>为运行AirSim环境的台式机的IP，<code>UdpIp</code>和<code>SitlIp</code>是跑SITL和ROS的笔记本的IP。其他的端口我修改过，若有自定义，对应修改即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;SeeDocsAt&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;Microsoft&#x2F;AirSim&#x2F;blob&#x2F;master&#x2F;docs&#x2F;settings.md&quot;,</span><br><span class="line">    &quot;SettingsVersion&quot;: 1.2,</span><br><span class="line">    &quot;SimMode&quot;: &quot;Multirotor&quot;,</span><br><span class="line">    &quot;Vehicles&quot;:&#123;</span><br><span class="line">        &quot;mav_00&quot;: &#123;</span><br><span class="line">            &quot;VehicleType&quot;: &quot;PX4Multirotor&quot;,</span><br><span class="line">            &quot;X&quot;: 0, &quot;Y&quot;: 0, &quot;Z&quot;: -1,</span><br><span class="line">            &quot;UseSerial&quot;: false,</span><br><span class="line">            &quot;LocalHostIp&quot;: &quot;192.168.3.2&quot;,</span><br><span class="line">            &quot;UdpIp&quot;: &quot;192.168.3.1&quot;,</span><br><span class="line">            &quot;UdpPort&quot;: 16200,</span><br><span class="line">            &quot;SitlIp&quot;: &quot;192.168.3.1&quot;,</span><br><span class="line">            &quot;SitlPort&quot;: 16100,</span><br><span class="line">            &quot;QgcHostIp&quot;: &quot;192.168.3.1&quot;,</span><br><span class="line">            &quot;QgcPort&quot;: 14550</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SITL </tag>
            
            <tag> AirSim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开发文档加载不再卡顿，亿点点提升</title>
      <link href="articles/2020-04%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/"/>
      <url>articles/2020-04%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<p>作为一个头(ku)秃(bi)的开发者，查阅各种文档是家常便饭，但由于中国特色在查阅一些文档时总是加载中。而且有时外场调试还不一定有网，因而将文档本地化是相当有必要的。本文介绍了一种将文档编译为静态网页并本地查阅的方法。</p><p>以Pixhawk飞控相关文档为例。APM的官方wiki是用Sphinx进行编译，支持的格式也比较丰富，编译为静态html后可以方便的查找和跳转。而PX4相关的文档主要是用gitbook进行编译管理，相比与Sphinx增加了多语言的切换，但作为静态网页挂载时无法直接跳转。因而考虑使用Nginx作为web服务器挂载网页gitbook类的文档。</p><p>建议以下的步骤都在Linux系统下操作，虚拟机或WSL。Win也可以，但会有这样那样的奇怪问题。</p><a id="more"></a><h2 id="APM文档本地化"><a href="#APM文档本地化" class="headerlink" title="APM文档本地化"></a>APM文档本地化</h2><p>APM文档的官方repo为<a href="https://github.com/ArduPilot/ardupilot_wiki%EF%BC%8C%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90%E5%90%8E%E6%90%AD%E5%BB%BA%E6%96%87%E6%A1%A3%E7%9A%84%E7%BC%96%E8%AF%91%E7%8E%AF%E5%A2%83%EF%BC%8C%E5%AE%98%E6%96%B9%E8%AF%B4%E6%98%8E%E5%9C%A8[%E8%BF%99%E9%87%8C](https://ardupilot.org/dev/docs/common-wiki-editing-infra-overview.html)%E3%80%82%E5%A4%A7%E4%BD%93%E6%98%AF%E5%AE%89%E8%A3%85%E4%BA%86sphinx%E7%9A%841.8.3%E7%89%88%E6%9C%AC%E7%84%B6%E5%90%8E%E8%A3%85%E4%BA%86%E4%B8%80%E4%BA%9B%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%AE%98%E6%96%B9%E6%8F%90%E4%BE%9B%E4%BA%86Docker%E5%92%8CVagrant%E7%9A%84%E7%9B%B8%E5%85%B3%E8%84%9A%E6%9C%AC%E3%80%82WSL%E6%88%96%E8%80%85%E8%99%9A%E6%8B%9F%E6%9C%BA%E8%BF%90%E8%A1%8C%60Sphinxsetup.sh%60%EF%BC%8C%E7%AD%89%E5%BE%85%E7%8E%AF%E5%A2%83%E8%AE%BE%E7%BD%AE%E5%AE%8C%E6%88%90%E5%90%8E%E5%9C%A8%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%60make%60%E5%8D%B3%E5%8F%AF%E4%BB%A5%E7%BC%96%E8%AF%91%E7%9B%B8%E5%85%B3%E7%9A%84%E5%85%A8%E9%83%A8%E6%96%87%E6%A1%A3%E3%80%82">https://github.com/ArduPilot/ardupilot_wiki，下载完成后搭建文档的编译环境，官方说明在[这里](https://ardupilot.org/dev/docs/common-wiki-editing-infra-overview.html)。大体是安装了sphinx的1.8.3版本然后装了一些插件，官方提供了Docker和Vagrant的相关脚本。WSL或者虚拟机运行`Sphinxsetup.sh`，等待环境设置完成后在根目录下`make`即可以编译相关的全部文档。</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 相关指令</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ArduPilot&#x2F;ardupilot_wiki.git</span><br><span class="line">cd ardupilot_wiki</span><br><span class="line">.&#x2F;Sphinxsetup.sh</span><br><span class="line">make</span><br></pre></td></tr></table></figure><p>编译完成截图</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-04%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/image-20200412175203199.png"></p><p>之前的版本目录会抽风来着，不过问题不大。新版本好像修复了这个问题</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-04%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/image-20200412180356005.png"></p><p>可以将主页的相关路径改为存放相关载具的路径，这样打开主页即可跳转相关的文档</p><p>打开<code>ardupilot\index.html</code>，定位到177行左右，将<code>https://ardupilot.org</code>替换为存放html主页的文件夹，比如<code>file:///F:/Progroming/_Doc_Src/ardupilot_wiki/_build</code></p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-04%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/image-20200412180434105.png"></p><p>之后编写一个python小脚本就可以方便的管理文档啦。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-04%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/image-20200412185144750.png"></p><h2 id="PX4文档本地化"><a href="#PX4文档本地化" class="headerlink" title="PX4文档本地化"></a>PX4文档本地化</h2><p>PX4的文档比APM更多更杂，常用的是PX4的开发者手册和Mavlink的开发者手册，相关的repo链接如下</p><p>分别为Mavlink的开发者手册，px4的开发手册和用户手册，qgc的开发手册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mavlink&#x2F;mavlink-devguide.git</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PX4&#x2F;dev.px4.io.git</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;PX4&#x2F;px4_user_guide.git</span><br><span class="line">https:&#x2F;&#x2F;github.com&#x2F;mavlink&#x2F;qgc-dev-guide.git</span><br></pre></td></tr></table></figure><p>gitbook编译文档比之前的方便，不过编译时各种插件还是有些bug（win上），linux上可以成功编译，安装好gitbook之后进行编译，生成<code>_book</code>目录以及相关的语言。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd &lt;dir of docs&gt;</span><br><span class="line">gitbook init</span><br><span class="line">gitbook build</span><br></pre></td></tr></table></figure><p>不过缺点是无法直接单击跳转，考虑用Nginx辅助，安装Nginx后修改配置文件</p><p>可以使用<code>nginx -t</code>命令查看<code>nginx.conf</code>的具体路径</p><p>在配置文件中的http中添加下面的配置，可以添加多个，修改玩配置文件后重启nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">listen       &lt;port_num&gt;;</span><br><span class="line">location &#x2F; &#123;</span><br><span class="line">root &lt;path of dir&gt;;</span><br><span class="line">index  index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以通过访问<code>127.0.0.1:&lt;port_num&gt;</code>愉快的使用本地文档啦</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-04%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/image-20200412182822115.png"></p><h2 id="伸手党的福利"><a href="#伸手党的福利" class="headerlink" title="伸手党的福利"></a>伸手党的福利</h2><p>当然，懒得走上面的编译流程可以直接下载编译好的文档，因为时间问题，没有把所有的文档都编译为最新版本，有需自取。后缀为文档的更新日期和git的commit hash，PX4文档的hash实在找不到了，只记得对应的版本了。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-04%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/image-20200412184540335.png"></p><p>关注公众号，并回复”无人机文档”下载相关文件</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-04%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3/qrcode.png"></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发文档 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>APM断点和单步调试（WIN）</title>
      <link href="articles/2020-02APM%E6%96%AD%E7%82%B9%E5%92%8C%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%EF%BC%88WIN%EF%BC%89/"/>
      <url>articles/2020-02APM%E6%96%AD%E7%82%B9%E5%92%8C%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%EF%BC%88WIN%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本篇分享WIN平台下如何对APM断点调试和单步调试，主要是基于WSL的编译环境和VScode作为编辑器</p><p>首先需要成功用WSL编译APM固件，由于不是重点会在文末提稍微提一下。</p><p>调试流程part1/疑难杂症part2/wsl环境搭建part3</p><a id="more"></a><h2 id="调试流程"><a href="#调试流程" class="headerlink" title="调试流程"></a>调试流程</h2><p>首先用vscode打开Ardupilot文件夹</p><p>设定vscode的launch任务，复制文本如下，有几个需要注意的点</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-02APM%E6%96%AD%E7%82%B9%E5%92%8C%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%EF%BC%88WIN%EF%BC%89/image-20200210210201210.png"></p><ol><li>“program”选项是在wsl里面的路径，wsl里面将win的cdef等盘挂载在<code>/mnt</code>目录下，对比win的路径修改一下。如果是rover则<code>ardurover</code>，copter是<code>arducopter</code>其他的fram对应修改一下</li><li>这个部分是告诉vscode实际的路径需要转化一下，搬运就行，注意改盘符</li><li>由于使用gdb进行调试，需要在wsl里面安装gdb，没有安装的话<code>sudo apt install gdb </code> ，一般gdb路径就在哪里</li></ol><p>设定完成后在wsl编译debug类型的sitl，以rover为例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;waf configure --debug</span><br><span class="line">.&#x2F;waf rover</span><br></pre></td></tr></table></figure><p>编译完成后在对应目录下启动仿真脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd APMrover2&#x2F;</span><br><span class="line">..&#x2F;Tools&#x2F;autotest&#x2F;sim_vehicle.py -N </span><br><span class="line">或者</span><br><span class="line">..&#x2F;Tools&#x2F;autotest&#x2F;sim_vehicle.py -D</span><br></pre></td></tr></table></figure><p>N为nobuild，编译过了加-N直接启动仿真</p><p>D为在启动仿真之前设置debug参数并重新编译</p><p>启动完成后切回vscode，按F5选择<code>ardurover</code>的进程，然后愉快的调试吧</p><p>可能有疑难杂症，转P2。</p><p>成功调试如图，支持断点支持单步。</p><p>F10/F11调试快捷键，单步执行或跳入</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-02APM%E6%96%AD%E7%82%B9%E5%92%8C%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%EF%BC%88WIN%EF%BC%89/image-20200210205649254.png"></p><h2 id="疑难杂症"><a href="#疑难杂症" class="headerlink" title="疑难杂症"></a>疑难杂症</h2><p>如果你在启动调试的时候看到这个，那么恭喜。产生它的原因很多，慢慢排除</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-02APM%E6%96%AD%E7%82%B9%E5%92%8C%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%EF%BC%88WIN%EF%BC%89/image-20200210205315000.png"></p><ol><li>WSL的设置</li></ol><p>一般都是这个，可以暂时的方法解决或者永久的，不过对WSL貌似电脑重启永久方法就失效来着</p><p>临时办法：WSL里面执行下面的命令再启动仿真脚本，产生报错好像和内核安全有关。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 0 | sudo tee &#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;yama&#x2F;ptrace_scope</span><br></pre></td></tr></table></figure><p>永久办法：设置<code>/etc/sysctl.d/10-ptrace.conf</code>里面的参数<code>kernel.yama.ptrace_scope = 0</code>然后重启服务<code>sudo service procps restart</code></p><ol start="2"><li>Vscode的launch文件路径设置有误</li></ol><p>检查盘符和对应的固件名称</p><ol start="3"><li>Vscode权限不足</li></ol><p>以管理员权限运行Vscode，遇到过几次，玄学bug</p><h2 id="WSL编译环境搭建"><a href="#WSL编译环境搭建" class="headerlink" title="WSL编译环境搭建"></a>WSL编译环境搭建</h2><p>假设你已经安装好了WSL，你需要做如下几步，下载代码，安装依赖，编译。</p><p>github日常被墙网速，大家自行解决</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 下载代码</span><br><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;ardupilot&#x2F;ardupilot.git</span><br><span class="line">cd ardupilot</span><br><span class="line">git submodule update --init --recursive</span><br><span class="line"></span><br><span class="line"># 安装依赖</span><br><span class="line">.&#x2F;Tools&#x2F;environment_install&#x2F;install-prereqs-ubuntu.sh -y</span><br></pre></td></tr></table></figure><p>然后就可以愉快的编译了。网络问题是个问题，不过应该问题不大。</p><p>请关注我吧~</p><p>会分享一些无人机和机器人的小技巧</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2020-02APM%E6%96%AD%E7%82%B9%E5%92%8C%E5%8D%95%E6%AD%A5%E8%B0%83%E8%AF%95%EF%BC%88WIN%EF%BC%89/qrcode-1581342418849.png"></p><p>P.S: 虽然说是WIN平台下，不过有些坎wsl还是跨不过去。在安装双系统用上Ubuntu之后感觉Ubuntu真香，大家不妨试试双系统。</p><p>然后公众号大概会保持月更的频率吧，不定期更新。</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> SITL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PX4飞控入门</title>
      <link href="articles/2019-12Arducopter/"/>
      <url>articles/2019-12Arducopter/</url>
      
        <content type="html"><![CDATA[<p>之前看到大神Su哥给大家带来关于SITL的分享，我也动了写一写什么的念头。</p><p>马上就2020了，之后的发展方向有了更多的选择。从大二开始连续参加两届大创加之今年暑假的电赛都用的是Pixhawk的硬件加ArduCopter固件进行无人机开发，积累了不少开发经验。但之后不一定会继续在无人机的路上走下去，又或者会在飞控和导航的方向深挖。便想写点什么记录和纪念下这些填坑的过程。</p><p>给大家分享一下关于WIN平台下Pixhawk的开发和SITL仿真。</p><a id="more"></a><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2019-12Arducopter/connect-to-com-port.jpg" style="zoom: 50%;" /> <p>Pixhawk的硬件支持APM和PX4两套固件，而两套固件的编译都需要在Linux下进行。官方推荐的是Ubuntu发行版，然而自从WIN1903支持WSL之后，win10就成了最好的Linux发行版(大雾)。其<a href="https://devblogs.microsoft.com/commandline/learn-about-windows-console-and-windows-subsystem-for-linux-wsl/">运行原理</a>比虚拟机少了一些中间层，可以理解为一个从系统API级别模拟Linux内核的应用。从目前的使用体验来看，WSL除了不支持opengl和部分USB外设比较遗憾外，已经可以满足大部分的开发需要了。而使用则可以当成只有命令行的Linux进行使用，也有特殊的方法可以配置GUI和其窗口，之后有机会的话会写。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2019-12Arducopter/LXSS-diagram-1024x472.jpg"></p><p>首先说一下我的开发环境吧，vscode+winterminal+wsl。</p><p>借助vscode的代码高亮和跳转进行编辑，然后在wsl完成Arducopter的<a href="https://ardupilot.org/dev/docs/building-setup-windows10.html">编译环境搭建</a>后，切换到代码目录下运行相关指令即可编译。</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2019-12Arducopter/image-20191230201909153.png"></p><p>而关于SITL仿真，可以理解为一个特殊的程序，它通过数值计算模拟载具的姿态和各种参数。可以通过不同的引擎看到它的仿真结果（数值图表和仿真模型的姿态）。Arducopter支持多种simulater（SITL Simulator,Gazebo,XPlane-10,RealFlight,Morse Replay,JSBSim,AirSim）比较常用的是SITL和Gazebo。<br>在Win平台下，通过WSL进行SITL仿真后可以通过地面站查看数据或通过仿真软件查看其姿态。<br>1.直接借助MP/QGC的地图指示观看，不过这样只有2D的粗略位置，无法更直观的看到姿态<br>2.借助FlightGear/XPlane/RealFlight等看到其更直观的姿态信息</p><p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2019-12Arducopter/image-20191230214532183.png"></p><p>关于WSL搭建开发环境<br>关于FG进行SITL仿真</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;Tools&#x2F;autotest&#x2F;sim_vehicle.py -L KSFO -v ArduCopter -N</span><br></pre></td></tr></table></figure><p>如果大家感兴趣我会写写如何用游戏手柄控制SITL仿真</p>]]></content>
      
      
      <categories>
          
          <category> 无人机 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> SITL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自定义Sublime编译系统</title>
      <link href="articles/2018-11%E8%87%AA%E5%AE%9A%E4%B9%89Sublime%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/"/>
      <url>articles/2018-11%E8%87%AA%E5%AE%9A%E4%B9%89Sublime%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>虽然网上已有不少关于<a href="https://blog.qiujinfeng.com/archives/making-Sublime-Text-cplusplus-IDE.html">sublime编译系统的教程</a>，但他们都没有解决python无法输入，c/c++文件编译无报错无回显等问题。</p><p>自定义Sublime的编译系统，完美解决python编译无法输入，C++编译无法报错等问题（基于VS2017）。并设置了8086的编译。</p><p>最开始折腾这些的想法是VS过于臃肿，最初折腾了MinGW的GCC和G++编译C，但编译无报错和是不是提示无法定位接口程序之类的十分蛋疼。之后查阅资料发现可以调用VS的cl编译便动了这个想法。不启动VS只是调用VS的编译器。</p><p>2018-12-22 </p><p>更新C++编译报错信息</p><p>汇编语言调试模式</p><p>后续：</p><p>vscode的折腾</p><p>调试相关</p><a id="more"></a><p>本文的所有编译脚本均以上传至<a href="https://github.com/BrightSoulXYHY/Sublime_Build">github</a></p><h2 id="Sublime的编译系统"><a href="#Sublime的编译系统" class="headerlink" title="Sublime的编译系统"></a>Sublime的编译系统</h2><p>sublime的编译系统为*.sublime-build，存于Sublime Text 64\Data\Packages\User文件夹下，可以自定义自己的编译系统，基本实例如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     &quot;shell_cmd&quot;:&quot;F:&#x2F;Progroming&#x2F;_Path&#x2F;build_cpp.bat $file_base_name $file_extension&quot;, </span><br><span class="line">    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,</span><br><span class="line">    &quot;working_dir&quot;: &quot;$&#123;file_path&#125;&quot;,</span><br><span class="line">    &quot;selector&quot;: &quot;source.c, source.c++&quot;,</span><br><span class="line">    &quot;encoding&quot;: &quot;cp936&quot;,</span><br><span class="line">   </span><br><span class="line">   &quot;variants&quot;:</span><br><span class="line">    [</span><br><span class="line">        &#123;   </span><br><span class="line">        &quot;name&quot;: &quot;Run&quot;,</span><br><span class="line">            &quot;shell_cmd&quot;: &quot;g++ -Wall -std&#x3D;c++11 \&quot;$&#123;file&#125;\&quot; -o \&quot;$&#123;file_base_name&#125;\&quot; &amp;&amp; start cmd &#x2F;c \&quot;\&quot;$&#123;file_path&#125;&#x2F;$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">key</th><th align="center">meaning</th></tr></thead><tbody><tr><td align="center">shell_cmd</td><td align="center">调用编译的DOS命令</td></tr><tr><td align="center">file_regex</td><td align="center">获取编译错误时的信息</td></tr><tr><td align="center">working_dir</td><td align="center">工作目录</td></tr><tr><td align="center">selector</td><td align="center">筛选器与自动编译相关，source标识语言文件的定义中寻找*.tmPreferences</td></tr><tr><td align="center">encoding</td><td align="center">编码格式[^1]</td></tr><tr><td align="center">variants</td><td align="center">同一编译模式下的不同选项，可自定义改变一些参数</td></tr><tr><td align="center">file_patterns</td><td align="center">编译系统应该支持的文件模式，可以自定义设置，形如：[“*.py”]</td></tr><tr><td align="center">[^1]: 编码格式参考链接：<a href="https://docs.python.org/3.3/library/codecs.html#id3">https://docs.python.org/3.3/library/codecs.html#id3</a></td><td align="center"></td></tr></tbody></table><p>一些常用的宏变量[^2]可以用于设置编译文件</p><p>[^2]: Sublime官方文档: <a href="https://www.sublimetext.com/docs/3/build_systems.html">https://www.sublimetext.com/docs/3/build_systems.html</a> </p><table><thead><tr><th align="center">宏选项</th><th align="center">意义</th></tr></thead><tbody><tr><td align="center">$file_path</td><td align="center">当前文件所在路径, 比如 C:\Files.</td></tr><tr><td align="center">$file</td><td align="center">当前文件的完整路径, 比如 C:\Files\Chapter1.txt.</td></tr><tr><td align="center">$file_name</td><td align="center">当前文件的文件名, 比如 Chapter1.txt.</td></tr><tr><td align="center">$file_extension</td><td align="center">当前文件的扩展名, 比如 txt.</td></tr><tr><td align="center">$file_base_name</td><td align="center">当前文件仅包含文件名的部分, 比如 Document.</td></tr><tr><td align="center">$packages</td><td align="center">Packages 文件夹的完整路径.</td></tr><tr><td align="center">$project</td><td align="center">当前项目文件的完整路径.</td></tr><tr><td align="center">$project_path</td><td align="center">当前项目文件的路径.</td></tr><tr><td align="center">$project_name</td><td align="center">当前项目文件的名称.</td></tr><tr><td align="center">$project_extension</td><td align="center">当前项目文件的扩展部分.</td></tr><tr><td align="center">$project_base_name</td><td align="center">当前项目仅包括名的部分.</td></tr></tbody></table><h2 id="自定义编译系统"><a href="#自定义编译系统" class="headerlink" title="自定义编译系统"></a>自定义编译系统</h2><p>虽然网上已有不少关于sublime编译系统的教程，但他们都没有解决python无法输入，c/c++文件编译无报错无回显等问题。</p><h3 id="python编译"><a href="#python编译" class="headerlink" title="python编译"></a>python编译</h3><p>由于python通过<code>&quot;shell_cmd&quot;:&quot;python -u $file&quot;</code>已经可以解决编译运行问题，考虑的是如何新建窗口并进行输入和自动关闭。多次试验<code>&quot;shell_cmd&quot;:&quot;cmd /k start&quot;</code>和<code>&quot;shell_cmd&quot;:&quot;cmd /c start&quot;</code>后反应到sublime最下的显示框也是一个cmd窗口，调用<code>cmd /k start</code>是多此一举。</p><p>直接<code>start cmd /c python -u $file_name </code>即可<br><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2018-11%E8%87%AA%E5%AE%9A%E4%B9%89Sublime%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/img-201811-01BuildPython.png" alt="效果演示" style="height:600px" /> </p><h3 id="C-C-编译"><a href="#C-C-编译" class="headerlink" title="C/C++编译"></a>C/C++编译</h3><p>一段时间的应用之后MinGW终于崩溃了，总算是动了解决它的心思。查阅VS2017官方文档[^3]，发现可以调用开发者工具将一个DOS命令窗设置为不同的编译环境<a href="%E8%AE%BE%E7%BD%AE%E4%B8%8D%E5%90%8C%E7%9A%84%E7%BC%96%E8%AF%91%E6%A8%A1%E5%BC%8F:https://docs.microsoft.com/en-us/cpp/build/building-on-the-command-line?view=vs-2017">^4</a>。因而解决问题的基本思路是打开DOS窗口设置为特定的编译环境，编译并运行*.exe。get✔</p><p>[^3]: MS官方文档: <a href="https://docs.microsoft.com/en-us/cpp/build/setting-the-path-and-environment-variables-for-command-line-builds?view=vs-2017">https://docs.microsoft.com/en-us/cpp/build/setting-the-path-and-environment-variables-for-command-line-builds?view=vs-2017</a></p><p>在<code>Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build</code>目录中找到了需要的文件，考虑到32位代码更为通用，选择<code>vcvars32.bat&quot;</code>进行设置。<br>编译脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@<span class="built_in">echo</span> off</span><br><span class="line">REM 将打开的dos设置为32位编译环境</span><br><span class="line">call <span class="string">&quot;D:\SoftWare\Microsoft Visual Studio\2017\Community\VC\Auxiliary\Build\vcvars32.bat&quot;</span></span><br><span class="line">cl /EHsc %1.%2</span><br><span class="line">start cmd /c %1.exe</span><br></pre></td></tr></table></figure><p>若代码编译报错显示错误信息和行号：</p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2018-11%E8%87%AA%E5%AE%9A%E4%B9%89Sublime%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/img-201811-01BuildCError.png" alt="效果演示" style="height:600px" /><p>成功编译演示：</p><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2018-11%E8%87%AA%E5%AE%9A%E4%B9%89Sublime%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/img-201811-01BuildCSucces.png" alt="" style="height:600px" /><h3 id="基于8086的汇编语言编译"><a href="#基于8086的汇编语言编译" class="headerlink" title="基于8086的汇编语言编译"></a>基于8086的汇编语言编译</h3><p>8086的汇编语言使用masm编译，奈何大部分机器不支持16位的远古程序因而得借用DOSBox模拟DOS进行编译和链接。关于<a href="https://www.dosbox.com/wiki/Basic_Setup_and_Installation_of_DosBoxhttps://www.dosbox.com/wiki/Basic_Setup_and_Installation_of_DosBox">DOSBox的设置参见</a></p><p>考虑到它是将一个文件夹目录映射为DOS的盘符，因而以下步骤需要将MASM全家桶和编译脚本放入一个固定的文件夹中。</p><p>查阅DOSBox的文档发现里面有一点启动选项的设置，果断使用执行name后退出的-exit选项，但效果不好。</p><p>最终在脚本中使用exit退出。</p><p><code>dosbox [name] [-exit] [-c command] [-fullscreen] [-userconf] ​       [-conf congfigfilelocation] [-lang languagefilelocation] ​       [-machine machine type] [-noconsole] [-startmapper] [-noautoexec] ​       [-securemode] [-scaler scaler | -forcescaler scaler] [-version] ​       [-socket socket]</code></p><blockquote><p>  name<br>​        If “name” is a directory it will mount that as the C: drive.<br>​        If “name” is an executable it will mount the directory of “name”<br>​        as the C: drive and execute “name”.</p><p>  -exit<br>​        DOSBox will close itself when the DOS application “name” ends.</p><p>  -c command<br>​        Runs the specified command before running “name”. Multiple commands<br>​        can be specified. Each command should start with “-c” though.<br>​        A command can be: an Internal Program, a DOS command or an executable<br>​        on a mounted drive.</p><p>  -noconsole (Windows Only)<br>​        Start DOSBox without showing DOSBox Status Window (console).<br>​        Output will be redirected to stdout.txt and stderr.txt</p></blockquote><img src="https://hexo-blog-bs.oss-cn-beijing.aliyuncs.com/_blog-img/2018-11%E8%87%AA%E5%AE%9A%E4%B9%89Sublime%E7%BC%96%E8%AF%91%E7%B3%BB%E7%BB%9F/img-201811-01BuildAssebble.png" alt="效果演示" style="height:600px" /> <p>新增调试模式Ctrl+Shift+B进入调试模式</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime </tag>
            
            <tag> Python </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Laplace变换</title>
      <link href="articles/2018-10laplace/"/>
      <url>articles/2018-10laplace/</url>
      
        <content type="html"><![CDATA[<p>拉普拉斯(Laplace)变换是分析和求解常系数线性微分方程的一种简便的方法，而且在自动控制系统的分析和综合中也起着重要的作用。</p><p>本文是学习完Laplace变换后的一些总结和归纳。</p><a id="more"></a><p>定义$\mathcal{L}[f(t)]=\int_{0}^{+\infty} f(t)e^{-st} dt = F(s)$</p><p>例1：$\mathcal{L}[e^{at}] = \frac {1}{s-a}$<br>$F(s)=\mathcal{L}[f(t)] = \int_0^{+\infty} e^{at}e^{-st} dt = \int_0^{+\infty} e^{-(s-a)t} dt = -\frac {1}{s-a}e^{-(s-a)t}|_0^{+\infty} = \frac {1}{s-a}$</p><p>例2：$\mathcal{L}[\cos{at}] = \frac {s}{s^2+a^2}$<br>$\because \cos {at} = \frac {1}{2}(e^{iat}+e^{-iat})$</p><p>$<br>\begin{eqnarray}<br>F(s)  &amp; = &amp; \mathcal{L}[f(t)] = \int_0^{+\infty} \frac {1}{2}(e^{iat}+e^{-iat})e^{-st} dt \<br>&amp; = &amp; \frac{1}{2} \int_0^{+\infty} e^{-(s-ai)t} dt + \int_0^{+\infty} e^{-(s+ai)t} dt) \<br>&amp; = &amp; \frac{1}{2} (\frac {1}{s-ai} + \frac {1}{s+ai}) = \frac {s}{s^2+a^2}<br>\end{eqnarray}<br>$</p><p>例3：$\mathcal{L}[\sin{at}] = \frac {s}{s^2+a^2}$<br>$\because \sin {at} = \frac {1}{2i}(e^{iat}-e^{-iat})$</p><p>$<br>\begin{eqnarray}<br>F(s) &amp; = &amp; \mathcal{L}[f(t)] = \int_0^{+\infty} \frac {1}{2i}(e^{iat}-e^{-iat})e^{-st} dt \<br>&amp; = &amp; \frac{1}{2i} \int_0^{+\infty} e^{-(s-ai)t} dt - \int_0^{+\infty} e^{-(s+ai)t} dt) \<br>&amp; = &amp; \frac{1}{2i} (\frac {1}{s-ai} - \frac {1}{s+ai}) = \frac {a}{s^2+a^2}<br>\end{eqnarray}<br>$</p><h2 id="Laplace变换简表"><a href="#Laplace变换简表" class="headerlink" title="Laplace变换简表"></a>Laplace变换简表</h2><table><thead><tr><th align="center">$f(t)$</th><th align="center">$\mathcal{L}[f(t)]$</th></tr></thead><tbody><tr><td align="center">$\delta(t)$</td><td align="center">1</td></tr><tr><td align="center">1</td><td align="center">$\frac{1}{s}$</td></tr><tr><td align="center">$t$</td><td align="center">$\frac{1}{s^2}$</td></tr><tr><td align="center">$t^n$</td><td align="center">$\frac{n!}{s^{n+1}}$</td></tr><tr><td align="center">$e^a$</td><td align="center">$\frac{1}{s-a}$</td></tr><tr><td align="center">$\cos at$/$\sin at$</td><td align="center">$\frac{s}{s^2+a^2}$/$\frac{a}{s^2+a^2}$</td></tr><tr><td align="center">$\cosh at$/$\sinh at$</td><td align="center">$\frac{s}{s^2-a^2}$/$\frac{a}{s^2-a^2}$</td></tr><tr><td align="center">$t\cos at$/$t\sin at$</td><td align="center">$\frac{s^2-a^2}{(s^2+a^2)}$/$\frac{2as}{(s^2+a^2)^2}$</td></tr><tr><td align="center">$t\cosh at$/$t\sinh at$</td><td align="center">$\frac{s^2+a^2}{(s^2-a^2)^2}$/$\frac{2as}{(s^2-a^2)^2}$</td></tr></tbody></table><h2 id="Lapace常用性质"><a href="#Lapace常用性质" class="headerlink" title="Lapace常用性质"></a>Lapace常用性质</h2><table><thead><tr><th align="center">性质</th><th align="center">表达式</th></tr></thead><tbody><tr><td align="center">线性性质</td><td align="center">齐次性</td></tr><tr><td align="center">线性性质</td><td align="center">叠加性</td></tr><tr><td align="center">微分性质</td><td align="center">$\mathcal{L}\left[ f^{\left( n \right)}\left( t \right) \right] =s^nF\left( s \right) -\sum_{i+j=n}^{}{s^if^{\left( j \right)}\left( 0 \right)}$</td></tr><tr><td align="center"></td><td align="center">$\mathcal{L}\left[ f’\left( t \right) \right] =sF\left( s \right) -f’\left( 0 \right)$</td></tr><tr><td align="center">积分性质</td><td align="center">$\mathcal{L}\left[ \int{f\left( t \right) dt} \right] =\frac{F\left( s \right)}{s}$</td></tr><tr><td align="center">位移性质</td><td align="center">$\mathcal{L}\left[ e^{at}f\left( t \right) \right] =F\left( s-a \right)$</td></tr><tr><td align="center">延迟性质</td><td align="center">$\mathcal{L}\left[ u\left( t-a \right) f\left( t-a \right) \right] =e^{-as}F\left( s \right) $</td></tr><tr><td align="center">终值/初值定理</td><td align="center">$\underset{t\rightarrow 0}{\lim}f\left( t \right) =\underset{s\rightarrow \infty}{\lim}sF\left( s \right) / \underset{t\rightarrow 0}{\lim}f\left( t \right) =\underset{s\rightarrow \infty}{\lim}sF\left( s \right)$</td></tr><tr><td align="center">卷积定理</td><td align="center">$\mathcal{L}\left[ \int_0^t{f_1\left( t-\tau \right) f_2\left( \tau \right) dt} \right] =F_1\left( s \right) F_2\left( s \right)$</td></tr></tbody></table><h2 id="Laplace逆变换的技巧"><a href="#Laplace逆变换的技巧" class="headerlink" title="Laplace逆变换的技巧"></a>Laplace逆变换的技巧</h2><p>一般而言Laplace$可以化为形如$$<br>F\left( s \right) =\frac{B\left( s \right)}{A\left( s \right)}=\frac{b_ms^m+b_{m-1}s^{m-1}+\cdots +b_1+b_0}{a_ns^n+a_{n-1}s^{n-1}+\cdots +a_1+a_0}<br>$的形式，而可以用因式分裂化为单个有理真分式。</p><p>当$A(s)=0$无重根时</p><p>$F\left( s \right) =\frac{B\left( s \right)}{\left( s-s_1 \right) \left( s-s_2 \right) \cdots \left( s-s_n \right)}$,可以化为$A\left( s \right) =\frac{c_i}{s-s_i}$，其中$c_i=\underset{s\rightarrow s_i}{\lim}\left( s-s_i \right) F\left( s \right) $</p><p>当$A(s)=0$有重根时</p><p>$F\left( s \right) =\frac{B\left( s \right)}{\left( s-s_1 \right) ^r\left( s-s_2 \right) \cdots \left( s-s_n \right)}$,非重根同上，重根部分求导</p><p>$c_1=\underset{s\rightarrow s_i}{\lim}\left( s-s_i \right)^r F\left( s \right) $</p><p>$c_n=\frac{1}{\left( n-1 \right) !}\underset{s\rightarrow s_i}{\lim}\frac{\text{d}^n}{\text{d}x^n}\left[ \left( s-s_i \right) F\left( s \right) \right] $</p><p>从而可以进行逆变换</p><p><strong>例</strong>：$F\left( s \right) =\frac{1}{\left( s-2 \right) \left( s-1 \right) ^2}$<br>$$<br>\begin{eqnarray}<br>&amp; c_1 &amp; =\underset{s\rightarrow 2}{\lim}\left( s-2 \right) F\left( s \right) =\frac{1}{\left( 2-1 \right) ^2}=1<br>\<br>&amp; c_2 &amp; =\underset{s\rightarrow 1}{\lim}\left( s-1 \right) ^2F\left( s \right) =\frac{1}{1-2}=-1<br>\<br>&amp; c_3 &amp; =\underset{s\rightarrow 1}{\lim}\frac{\text{d}}{\text{d}x}\left( s-1 \right) ^2F\left( s \right) =-\frac{1}{\left( 1-2 \right) ^2}=-1<br>\<br>&amp; F &amp;\left( s \right) =\frac{1}{\left( s-2 \right) \left( s-1 \right) ^2}=\frac{1}{s-2}-\frac{1}{\left( s-1 \right) ^2}+\frac{1}{s-1}<br>\end{eqnarray}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 热爱学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数学 </tag>
            
            <tag> 自动控制原理 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
